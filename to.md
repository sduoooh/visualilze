1. 使用索引缓冲区进行重复顶点的取消绘制，见[索引缓冲区](https://webgpufundamentals.org/webgpu/lessons/zh_cn/webgpu-vertex-buffers.html#a-index-buffers);

2. 体数据更新时，将```SAB```内数据直接存入大```Staging Buffer```进行缓存，注意内存布局满足对齐要求;

3. 体数据传入以3D的```Texure```形式，格式使用```r32float```，颜色映射表则使用1D的```Texure```, 参考4个字节放RGBA;

4. ```render-worker```还得加个摄像头坐标(在主线程通过鼠标事件计算完成)的```SAB```以更新转换矩阵，考虑在JS内计算转换矩阵。

#

1. ```loadChannel``` 应该给 ```render-worker```一份;
2. 考虑是否直接在```render-worker```取opfs数据，或者```sub-worker```化```opfs-laod```。

#

1. 观察到延迟渲染和累积效果渲染均与调用 ```updateStagingBuffer``` 的节点有关，该节点前后出现渲染更新；(依旧存在)
2. 图像锯齿较为明显； （√）
3. 旋转方位不对，应该是坐标系问题；（√）
4. 长方体能渲染，但是全红，同时顶点着色器相同的情况下比最小用例小一截，且通过挪视角发现似乎并不完整，挪的角度大一些会直接透明（明明关掉了背面三角形剔除）。（√）

#

1. 可以确定，延迟渲染源于疑似 ```copyBufferToTexture``` 函数对 ```Buffer``` 的破坏性复制，导致其出现被销毁或其他情况，从而下一次 ```render``` 时调用获得纹理失败，至调用 ```updateStagingBuffer``` 时重置Buffer。尝试在所有更新 ```fileindex``` 函数强制调用 ```updateStagingBuffer``` ，则这些情况下渲染被实际触发更新；尝试将双缓冲替换为可映射的 ```Buffer```， 因为轮换导致的索引对少量测试数据索引完全囊括不能触发更新，导致渲染更新失去。两次尝试强烈印证前诉原因。但是通过多渠道搜索，没有类似支持该特性存在的讨论。
2. 通过输出 ```nor``` 为颜色可知，渲染更新延迟一个循环，目前不清楚原因，没有产生可信的猜测。
3. 光线投射实现优化，但是依旧只会呈现全红。一方面检查数据发现数据的确近乎全零，调整时间步长后依旧，这可能是步数过少所致；另一方面，与前诉管线问题也许有关系。

#

1. 目前前端问题除通信外基本解决，通信似乎是因为后端无法多线程导致？不敢确定。
2. 后端的雷克子波传播过慢且并不如示例性质，并且一定时长后会 ```NaN``` 。
3. 前端可以考虑优化采样+过滤。 